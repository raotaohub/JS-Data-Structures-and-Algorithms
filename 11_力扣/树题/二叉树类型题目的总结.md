### åšäº†æ ‘ç±»å‹çš„å‡ é“é¢˜ï¼Œå‘ç°ä¸€äº›äº›å…±æ€§ï¼Œåšç‚¹å°æ€»ç»“å§

é¦–å…ˆå¤§å¤šäºŒå‰æ ‘çš„é—®é¢˜éƒ½å¯ä»¥ç”¨DFSå’ŒBFSæ¥å¤„ç†ï¼Œ

DFS

- é€’å½’
- è¿­ä»£

BFS

- è¿­ä»£



æ ‘çš„æœ€å¤§æ·±åº¦

> æ·±åº¦çš„æ¦‚å¿µï¼Œå¯ä»¥åˆ©ç”¨å±‚åºéå†æ¥è§£å†³ï¼Œéå†ä¸€å±‚ï¼Œæ·±åº¦å°±+1

```javascript
//ä¸€ä¸ªé€šç”¨çš„BFSæ¨¡æ¿
function bfs(root){
    // if(!root) return 'å¯æ ¹æ®é¢˜ç›®æ¥è¿”å›' è¿™é‡Œå¯ä»¥åšè¾¹ç•Œåˆ¤æ–­
    // é€šå¸¸å€ŸåŠ©ä¸€ä¸ªé˜Ÿåˆ—æ¥å®ç°
    let queue = [root]
     let depah = 0 // ç”¨ä½œè®°å½•å±‚æ•°
    
    while(queue.length){
        let j = queue.length
        // å¦‚æœæ˜¯è¿­ä»£åˆ™å¯ä»¥ğŸ‘‡
        while(j--){
        	let node = queue.shift()
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
            //é€»è¾‘å¤„ç† æ ¹æ®éœ€è¦è¿›è¡Œ å‰ ä¸­ åçš„å¤„ç†
            
        }
        depah++
    }
    return depah
}
//DFSæ³•
var maxDepth = function (root) {
    if (!root) return 0	// ç»ˆæ­¢æ¡ä»¶
    let left = maxDepth(root.left)
    let right = maxDepth(root.right)
    return Math.max(left, right) + 1
};
```



æ ‘çš„æœ€å¤§é«˜åº¦

äºŒå‰æ ‘çš„ç›´å¾„



äºŒå‰æ ‘çš„æ„å»º

- 1ã€å‰åºæ„å»º

- ```javascript
     // BFS æ³•
  	const deserialize = (data) => {
        if (data == 'X') return null;
  
        const list = data.split(',');  // æŒ‰,è½¬æˆæ•°ç»„
  
        const root = new TreeNode(list[0]); // è·å–é¦–é¡¹ï¼Œæ„å»ºæ ¹èŠ‚ç‚¹
        const queue = [root];          // æ ¹èŠ‚ç‚¹æ¨å…¥é˜Ÿåˆ—
        let cursor = 1;                // åˆå§‹æŒ‡å‘listç¬¬äºŒé¡¹
  
        while (cursor < list.length) { // æŒ‡é’ˆè¶Šç•Œï¼Œå³æ‰«å®Œäº†åºåˆ—åŒ–å­—ç¬¦ä¸²
          const node = queue.shift();  // è€ƒå¯Ÿå‡ºåˆ—çš„èŠ‚ç‚¹
  
          const leftVal = list[cursor];      // å®ƒçš„å·¦å„¿å­çš„å€¼
          const rightVal = list[cursor + 1]; // å®ƒçš„å³å„¿å­çš„å€¼
  
          if (leftVal != 'X') {              // æ˜¯çœŸå®èŠ‚ç‚¹
            const leftNode = new TreeNode(leftVal); // åˆ›å»ºå·¦å„¿å­èŠ‚ç‚¹
            node.left = leftNode;                   // è®¤çˆ¶äº²
            queue.push(leftNode);                   // è‡ªå·±ä¹Ÿæ˜¯çˆ¶äº²ï¼Œå…¥åˆ—
          }
          if (rightVal != 'X') {
            const rightNode = new TreeNode(rightVal);
            node.right = rightNode;
            queue.push(rightNode);
          }
          cursor += 2; // ä¸€æ¬¡è€ƒå¯Ÿä¸€å¯¹å„¿å­ï¼ŒæŒ‡é’ˆåŠ 2
        }
        return root;  // BFSç»“æŸï¼Œæ„å»ºç»“æŸï¼Œè¿”å›æ ¹èŠ‚ç‚¹
      };
  
  // DFS
      var deserialize = function (data) {
        let values = JSON.parse(data);
  
        return (function getTree() {
          let value = values.shift();
          if (value === null) return null;
  
          let node = new TreeNode(value); // æ ¹
          node.left = getTree();          // å·¦
          node.right = getTree();         // å³
  
          return node;
  
        })();
  
      };
  ```



- 2ã€ä¸­åºæ„å»º

- ```javascript
  // å°†æœ‰åºåˆ—è¡¨æ„å»ºæˆä¸€ä¸ªäºŒå‰æœç´¢æ ‘ [-10,-3,0,5,9] äºŒåˆ†æ€æƒ³
  // https://leetcode-cn.com/problems/minimum-height-tree-lcci/
  var sortedArrayToBST = function (nums) {
  
      if (nums.length === 0) return null
  
      let mid = Math.floor(nums.length / 2) 
  
      let root = new TreeNode(nums[mid]) // ä¸­
  
      root.left = sortedArrayToBST(nums.slice(0, mid))// å·¦
      root.right = sortedArrayToBST(nums.slice(mid + 1))// å³
  
      return root
  }
  
  ```



