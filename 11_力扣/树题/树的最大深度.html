<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 递归写法
    var maxDepth = function (root) {
      return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
    // 也可以写成这样
    var maxDepth = function (root) {
      if (root == null) return 0
      let left = maxDepth(root.left)
      let right = maxDepth(root.right)
      return Math.max(left, right) + 1
    }
    // BFS(典型的BFS模板写法)
    var maxDepth = function (root) {
      if (root == null) return 0

      let queue = [root]   // 需要借助一个 队列数据结构

      let depah = 1

      while (queue.length) {
        // 保存当前队列的长度
        const leve = queue.length
        for (let i = 0; i < leve; i++) {
          const cur = queue.shift()
          if (cur.left) { queue.push(cur.left) }
          if (cur.right) { queue.push(cur.right) }
        }
        if (queue.length) {
          depah++
        }
      }
      return depah
    }
    // 经典BFS模板2
    var maxDepth = function (root) {
      if (!root) return 0

      let queue = [root]
      let depth = 0
      let j

      while (queue.length) {
        j = queue.length

        for (let i = 0; i < j; i++) {   //也可写成 while(j--); 意思是把当前栈清空 然后压入左右节点
          const curNode = queue.shift() // 队列先进先出
          if (curNode.left) queue.push(curNode.left)
          if (curNode.right) queue.push(curNode.right)
        }
        depth++
      }
      return depth
    }
  </script>

</body>

</html>
<script>
  // 树的遍历法
  function dfs(root) {
    if (满足特定条件) {
      // 返回结果 or 退出搜索空间
    }
    // 主要逻辑在这就是 前序遍历
    dfs(root.left)
    // 主要逻辑在这就是 中序遍历
    dfs(root.right)
    // 主要逻辑在这就是 后序遍历
    // 也存在混合的情况
  }
</script>