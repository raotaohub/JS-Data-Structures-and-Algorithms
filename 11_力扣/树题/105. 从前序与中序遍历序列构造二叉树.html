<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>105. 从前序与中序遍历序列构造二叉树</title>
</head>

<body>
  <!-- 
  根据一棵树的前序遍历与中序遍历构造二叉树。
    前序遍历 preorder = [3,9,20,15,7]
    中序遍历 inorder = [9,3,15,20,7]
      返回如下的二叉树：
             3
            / \
            9  20
              /  \
            15   7
    核心的思想是，只要直到root的值，就可以在中序遍历的结果，区分左右子树的构成。
    恰好这里提供了前序遍历结果，也就得到了 root 的值。

    通过递归重复这个构建过程 即可。
   -->
  <script>
    var buildTree = function (preorder, inorder) {

      if (!preorder.length || !inorder.length) return null

      const root = new TreeNode(preorder[0]) // 前序第1个元素 是root
      const mid = inorder.indexOf(root.val) // 找到中序 root 的下标 


      // 在前序数组中root的位置是确定的就是 index = 0 , 左子树结束的数组区间 就是 index = mid 的位置
      root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid))
      root.right = buildTree(preorder.slice(mid + 1,), inorder.slice(mid + 1))


      return root
    };

  </script>
</body>

</html>