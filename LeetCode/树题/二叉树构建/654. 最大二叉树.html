<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>654. 最大二叉树</title>
</head>
<!-- 
    给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

    创建一个根节点，其值为 nums 中的最大值。
    递归地在最大值 左边 的 子数组前缀上 构建左子树。
    递归地在最大值 右边 的 子数组后缀上 构建右子树。

    输入：nums = [3,2,1,6,0,5]
    输出：[6,3,5,null,2,0,null,null,1]
    解释：nums 最大的是 6 
         那么nums 3~1 用于构建左树
         那么nums 0~5 用于构建右树


 -->
<script>
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {number[]} nums
     * @return {TreeNode}
     */

    function findMax(nums, l, r) {
        let maxIdx = l; max = 0
        for (let i = l; i <= r; i++) {
            if (max < nums[i]) {
                max = nums[i]
                maxIdx = i
            }
        }

        return maxIdx
    }
    function build(nums, l, r) {
        if (l > r) return null

        const maxIdx = findMax(nums, l, r)

        const root = new TreeNode(nums[maxIdx])

        root.left = build(nums, l, maxIdx - 1)
        root.right = build(nums, maxIdx + 1, r)

        return root
    }

    var constructMaximumBinaryTree = function (nums) {

        return build(nums, 0, nums.length - 1)
    };
</script>

<body>

</body>

</html>